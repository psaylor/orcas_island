'use strict';
var fs = require('fs');
var parse = require('csv').parse;
var transform = require('csv').transform;


var parseOptions = {
	delimiter: ' ',  // use one space to delimit columns
	auto_parse: true,  // convert read data types to native types
	columns: ['start_sample', 'end_sample', 'phoneme', 'word', 'word_boundary'],
};
var parser = parse(parseOptions);
var SROutputFile = fs.createReadStream('./assets/utterance_0.txt');


// stateful transformer
var gen_transform_function = function () {

	var gathering = false;
	var current_object = null;

	var filler_regex = /<[a-zA-Z]+>/;
	var silence_phoneme = 'sil';

	var transform_reduce_function = function(record) {
		// console.log("Transforming record: ", record);
		var word_boundary = record.word_boundary;

		if (gathering && current_object) {

			// add the phoneme from this row
			var phoneme = record.phoneme;
			if (phoneme !== silence_phoneme) {
				current_object.phonemes.push(phoneme);
			}

			// set end and emit if it's the end of the word
			if (word_boundary === 'E') {
				current_object.end_sample = record.end_sample;
				gathering = false;
				var return_object = current_object;
				current_object = null;
				if (!return_object.hesitation) {
					return return_object;
				}
				
			} 

		} else { // non-gathering state

			if (word_boundary === 'I') {
				gathering = true; // now in gathering state
				current_object = {
					start_sample : record.start_sample,
					word : record.word,
					phonemes : (record.phoneme !== silence_phoneme) ? [record.phoneme] : [],  // accumulate the phonemes in a list,
					hesitation : filler_regex.test(record.word),
				};

			} else if (word_boundary === 'IE') {
				var return_object = {
					start_sample : record.start_sample,
					end_sample : record.end_sample,
					word : record.word,
					phonemes : [record.phoneme],  // accumulate the phonemes in a list,
					hesitation : filler_regex.test(record.word),
				};
				if (return_object.hesitation) {
					// hesitation like <uh> or <um>
				} else {
					// emit the current object if it's not filler
					return return_object;
				}
				
			}
			// ignore other rows b/c not in gathering state
		}
		return null;

	};


	return transform_reduce_function;
};

var transformer = transform(gen_transform_function());

SROutputFile.pipe(parser).pipe(transformer);
transformer.on('readable', function() {
	var row;
	while (row = transformer.read()) {
		console.log(row);
	}
});
